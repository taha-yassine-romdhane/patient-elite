import { Task, TaskType, createDiagnosticTask, createPaymentReminderTask, createOverduePaymentTask } from './taskUtils';

const STORAGE_KEY = 'calendarTasks';

interface PaymentData {
  id: string;
  amount: number;
  type: string;
  dueDate?: string | Date;
  overdueDate?: string | Date;
  isOverdue?: boolean;
  overdueDays?: number;
  reminderSent?: boolean;
  cashRest?: number;
  cashRestDate?: string;
  cnamStatus?: string;
  cnamFollowupDate?: string;
}

interface RentalData {
  id: string;
  patient: {
    fullName: string;
  };
  rentalItems?: {
    payments: PaymentData[];
  }[];
  rentalGroups?: {
    payments: PaymentData[];
    rentalItems: {
      payments: PaymentData[];
    }[];
  }[];
}

export class TaskManager {
  private tasks: Task[] = [];
  private loadedAutoTasks = new Set<string>();

  constructor() {
    if (typeof window !== 'undefined') {
      this.loadTasks();
    }
  }

  private loadTasks(): void {
    try {
      const savedTasks = localStorage.getItem(STORAGE_KEY);
      if (savedTasks) {
        this.tasks = JSON.parse(savedTasks);
        // Load auto-generated task IDs to avoid duplicates
        this.tasks.forEach(task => {
          if (task.type !== "CUSTOM") {
            this.loadedAutoTasks.add(task.id);
          }
        });
      }
    } catch (error) {
      console.error('Error loading tasks:', error);
      this.tasks = [];
    }
  }

  private saveTasks(): void {
    if (typeof window === 'undefined') {
      return;
    }
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(this.tasks));
    } catch (error) {
      console.error('Error saving tasks:', error);
    }
  }

  getTasks(): Task[] {
    return [...this.tasks];
  }

  addTask(task: Omit<Task, 'id' | 'createdAt'>): Task {
    const newTask: Task = {
      ...task,
      id: `manual-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      createdAt: new Date().toISOString()
    };

    this.tasks.push(newTask);
    this.saveTasks();
    return newTask;
  }

  updateTask(taskId: string, updates: Partial<Task>): boolean {
    const index = this.tasks.findIndex(task => task.id === taskId);
    if (index === -1) return false;

    this.tasks[index] = { ...this.tasks[index], ...updates };
    this.saveTasks();
    return true;
  }

  deleteTask(taskId: string): boolean {
    const index = this.tasks.findIndex(task => task.id === taskId);
    if (index === -1) return false;

    this.tasks.splice(index, 1);
    this.saveTasks();
    return true;
  }

  toggleTaskCompletion(taskId: string): boolean {
    const task = this.tasks.find(t => t.id === taskId);
    if (!task) return false;

    task.completed = !task.completed;
    this.saveTasks();
    return true;
  }

  async loadAutoGeneratedTasks(): Promise<void> {
    try {
      // Load diagnostic tasks
      await this.loadDiagnosticTasks();
      
      // Load payment tasks (if implemented)
      // await this.loadPaymentTasks();
      
      // Remove duplicate tasks based on ID
      this.removeDuplicateTasks();
      
      this.saveTasks();
    } catch (error) {
      console.error('Error loading auto-generated tasks:', error);
    }
  }

  private removeDuplicateTasks(): void {
    const seen = new Set<string>();
    this.tasks = this.tasks.filter(task => {
      if (seen.has(task.id)) {
        return false;
      }
      seen.add(task.id);
      return true;
    });
  }

  private async loadDiagnosticTasks(): Promise<void> {
    try {
      const response = await fetch('/api/diagnostics');
      if (!response.ok) return;

      const diagnostics = await response.json();
      const severeDiagnostics = diagnostics.filter((d: { iahResult: number }) => d.iahResult >= 30);

      for (const diagnostic of severeDiagnostics) {
        const taskId = `diag-${diagnostic.id}`;
        
        // Skip if already loaded
        if (this.loadedAutoTasks.has(taskId)) continue;

        const task = createDiagnosticTask(diagnostic);
        if (task) {
          this.tasks.push(task);
          this.loadedAutoTasks.add(taskId);
        }
      }
    } catch (error) {
      console.error('Error loading diagnostic tasks:', error);
    }
  }

  addSalePaymentTasks(saleId: string, patientName: string, payments: PaymentData[]): void {
    for (const payment of payments) {
      // Cash rest payment task
      if (payment.cashRest && payment.cashRest > 0 && payment.cashRestDate) {
        const taskId = `cash-rest-${saleId}`;
        
        // Skip if already exists
        if (this.loadedAutoTasks.has(taskId)) continue;

        const task: Task = {
          id: taskId,
          title: `Rappel paiement reste`,
          description: `Reste à payer: ${payment.cashRest.toFixed(2)} TND pour ${patientName}`,
          type: "PAYMENT_REMINDER",
          priority: "MEDIUM",
          date: payment.cashRestDate,
          dueDate: payment.cashRestDate,
          completed: false,
          patientName,
          relatedData: { saleId, amount: payment.cashRest, paymentType: "CASH_REST" },
          createdAt: new Date().toISOString(),
          notifications: {
            enabled: true,
            reminderDate: new Date(new Date(payment.cashRestDate).getTime() - 24 * 60 * 60 * 1000)
              .toISOString().split('T')[0]
          }
        };

        this.tasks.push(task);
        this.loadedAutoTasks.add(taskId);
      }

      // CNAM follow-up task
      if (payment.cnamStatus === "ATTENTE" && payment.cnamFollowupDate) {
        const taskId = `cnam-followup-${saleId}`;
        
        // Skip if already exists
        if (this.loadedAutoTasks.has(taskId)) continue;

        const task: Task = {
          id: taskId,
          title: `Suivi CNAM en attente`,
          description: `Vérifier le statut CNAM pour ${patientName} - Montant: ${payment.amount.toFixed(2)} TND`,
          type: "CNAM_FOLLOWUP",
          priority: "HIGH",
          date: payment.cnamFollowupDate,
          dueDate: payment.cnamFollowupDate,
          completed: false,
          patientName,
          relatedData: { saleId, amount: payment.amount, paymentType: "CNAM_FOLLOWUP" },
          createdAt: new Date().toISOString(),
          notifications: {
            enabled: true,
            reminderDate: new Date(new Date(payment.cnamFollowupDate).getTime() - 24 * 60 * 60 * 1000)
              .toISOString().split('T')[0]
          }
        };

        this.tasks.push(task);
        this.loadedAutoTasks.add(taskId);
      }
    }

    this.saveTasks();
  }

  addRentalPaymentTasks(rentalId: string, patientName: string, payments: PaymentData[]): void {
    for (const payment of payments) {
      // Payment reminder task
      const reminderTask = createPaymentReminderTask(payment, patientName, rentalId);
      if (reminderTask) {
        const taskId = reminderTask.id;
        
        // Skip if already exists
        if (this.loadedAutoTasks.has(taskId)) continue;

        this.tasks.push(reminderTask);
        this.loadedAutoTasks.add(taskId);
      }

      // Overdue payment task
      const overdueTask = createOverduePaymentTask(payment, patientName, rentalId);
      if (overdueTask) {
        const taskId = overdueTask.id;
        
        // Skip if already exists
        if (this.loadedAutoTasks.has(taskId)) continue;

        this.tasks.push(overdueTask);
        this.loadedAutoTasks.add(taskId);
      }
    }

    this.saveTasks();
  }

  // Update overdue payment statuses and create tasks
  updateOverduePayments(rentals: RentalData[]): void {
    const today = new Date();
    
    for (const rental of rentals) {
      const patientName = rental.patient?.fullName || 'Patient inconnu';
      
      // Check individual rental item payments
      if (rental.rentalItems) {
        for (const item of rental.rentalItems) {
          if (item.payments) {
            for (const payment of item.payments) {
              this.processPaymentForOverdue(payment, patientName, rental.id, today);
            }
          }
        }
      }
      
      // Check rental group payments
      if (rental.rentalGroups) {
        for (const group of rental.rentalGroups) {
          // Check shared payments
          if (group.payments) {
            for (const payment of group.payments) {
              this.processPaymentForOverdue(payment, patientName, rental.id, today);
            }
          }
          
          // Check individual item payments within groups
          if (group.rentalItems) {
            for (const item of group.rentalItems) {
              if (item.payments) {
                for (const payment of item.payments) {
                  this.processPaymentForOverdue(payment, patientName, rental.id, today);
                }
              }
            }
          }
        }
      }
    }
    
    this.saveTasks();
  }

  private processPaymentForOverdue(payment: PaymentData, patientName: string, rentalId: string, today: Date): void {
    const dueDate = payment.dueDate ? new Date(payment.dueDate) : null;
    const overdueDate = payment.overdueDate ? new Date(payment.overdueDate) : null;
    
    if (!dueDate || !overdueDate) return;
    
    const isOverdue = today > overdueDate;
    
    // Create or update overdue task
    if (isOverdue) {
      const taskId = `overdue-payment-${payment.id}`;
      
      // Remove existing task if it exists
      this.tasks = this.tasks.filter(task => task.id !== taskId);
      this.loadedAutoTasks.delete(taskId);
      
      // Create new overdue task
      const overdueTask = createOverduePaymentTask(payment, patientName, rentalId);
      if (overdueTask) {
        this.tasks.push(overdueTask);
        this.loadedAutoTasks.add(taskId);
      }
    }
    
    // Create reminder task if due soon
    const daysUntilDue = Math.ceil((dueDate.getTime() - today.getTime()) / (1000 * 60 * 60 * 24));
    if (daysUntilDue <= 3 && daysUntilDue >= 0) {
      const reminderTaskId = `payment-reminder-${payment.id}`;
      
      // Skip if already exists
      if (this.loadedAutoTasks.has(reminderTaskId)) return;
      
      const reminderTask = createPaymentReminderTask(payment, patientName, rentalId);
      if (reminderTask) {
        this.tasks.push(reminderTask);
        this.loadedAutoTasks.add(reminderTaskId);
      }
    }
  }

  getTasksByDate(date: string): Task[] {
    return this.tasks.filter(task => task.date === date);
  }

  getTasksByType(type: TaskType): Task[] {
    return this.tasks.filter(task => task.type === type);
  }

  getUpcomingTasks(days: number = 3): Task[] {
    const today = new Date();
    const futureDate = new Date(today.getTime() + days * 24 * 60 * 60 * 1000);
    
    return this.tasks.filter(task => {
      const taskDate = new Date(task.date);
      return taskDate >= today && taskDate <= futureDate && !task.completed;
    });
  }

  getFilteredTasks(filter: "ALL" | TaskType): Task[] {
    if (filter === "ALL") return this.tasks;
    return this.tasks.filter(task => task.type === filter);
  }

  checkNotifications(): void {
    const upcomingTasks = this.getUpcomingTasks();
    const urgentTasks = upcomingTasks.filter(task => 
      task.priority === "URGENT" || task.priority === "HIGH"
    );

    if (urgentTasks.length > 0 && Notification.permission === "granted") {
      urgentTasks.forEach(task => {
        if (!task.notifications.reminderSent) {
          new Notification(`Tâche prioritaire: ${task.title}`, {
            body: task.description,
            icon: "/favicon.ico"
          });
          
          // Mark as sent
          task.notifications.reminderSent = true;
          this.saveTasks();
        }
      });
    }
  }

  clearAllTasks(): void {
    this.tasks = [];
    this.loadedAutoTasks.clear();
    this.saveTasks();
  }

  clearCompletedTasks(): void {
    this.tasks = this.tasks.filter(task => !task.completed);
    this.saveTasks();
  }

  exportTasks(): string {
    return JSON.stringify(this.tasks, null, 2);
  }

  importTasks(tasksJson: string): boolean {
    try {
      const importedTasks = JSON.parse(tasksJson);
      if (Array.isArray(importedTasks)) {
        this.tasks = importedTasks;
        this.saveTasks();
        return true;
      }
    } catch (error) {
      console.error('Error importing tasks:', error);
    }
    return false;
  }
}

// Singleton instance
export const taskManager = new TaskManager();